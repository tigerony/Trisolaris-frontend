import { Contract, ProxyAdminProject, AppProject, BuildArtifacts, App, TxParams } from '@openzeppelin/upgrades';
import { AppProjectDeployer, ProxyAdminProjectDeployer } from './ProjectDeployer';
import LocalController from '../local/LocalController';
import ContractManager from '../local/ContractManager';
import NetworkFile, { ProxyInterface } from '../files/NetworkFile';
import ProjectFile from '../files/ProjectFile';
import { ProxyType } from '../../scripts/interfaces';
declare type Project = ProxyAdminProject | AppProject;
declare type ProjectDeployer = ProxyAdminProjectDeployer | AppProjectDeployer;
export default class NetworkController {
    localController: LocalController;
    txParams: TxParams;
    network: string;
    networkFile: NetworkFile;
    project: Project;
    contractManager: ContractManager;
    constructor(network: string, txParams: TxParams, networkFile?: NetworkFile);
    get projectFile(): ProjectFile;
    get projectVersion(): string;
    get currentVersion(): string;
    get currentManifestVersion(): string;
    get packageAddress(): string;
    get proxyAdminAddress(): string;
    get proxyFactoryAddress(): string;
    checkNotFrozen(): void | never;
    fetchOrDeploy(requestedVersion: string): Promise<Project>;
    deployChangedSolidityLibs(contractNames: string): Promise<void>;
    push(aliases: string[] | undefined, { reupload, force }?: {
        reupload?: boolean;
        force?: boolean;
    }): Promise<void | never>;
    deployProxyFactory(): Promise<void>;
    deployProxyAdmin(): Promise<void>;
    private _checkVersion;
    private _newVersionRequired;
    private _contractsListForPush;
    private getLibsToDeploy;
    private _solidityLibsForPush;
    uploadSolidityLibs(libs: Contract[]): Promise<void>;
    private _uploadSolidityLib;
    uploadContracts(contracts: [string, Contract][]): Promise<void>;
    uploadContract(contractAlias: string, contract: Contract): Promise<void | never>;
    private _setSolidityLibs;
    private _unsetSolidityLibs;
    private _unsetSolidityLib;
    private _hasChangedLibraries;
    private _getAllSolidityLibNames;
    private _populateDependencyGraph;
    private _getContractDependencies;
    unsetContracts(): Promise<void>;
    unsetContract(contractAlias: string): Promise<void | never>;
    validateContracts(contracts: [string, Contract][], buildArtifacts: BuildArtifacts): boolean;
    validateContract(contractAlias: string, contract: Contract, buildArtifacts: BuildArtifacts): boolean;
    checkContractDeployed(packageName: string, contractAlias: string, throwIfFail?: boolean): void;
    checkLocalContractsDeployed(throwIfFail?: boolean): void;
    private _errorForLocalContractsDeployed;
    checkLocalContractDeployed(contractAlias: string, throwIfFail?: boolean): void;
    private _errorForLocalContractDeployed;
    private _handleErrorMessage;
    private _hasSolidityLibChanged;
    hasContractChanged(contractAlias: string, contract?: Contract): boolean;
    isLocalContract(contractAlias: string): boolean;
    isContractDefined(contractAlias: string): boolean;
    isContractDeployed(contractAlias: string): boolean;
    verifyAndPublishContract(contractAlias: string, optimizer: boolean, optimizerRuns: string, remote: string, apiKey: string): Promise<void>;
    writeNetworkPackageIfNeeded(): void;
    freeze(): Promise<void | never>;
    get isPublished(): boolean;
    getDeployer(requestedVersion: string): ProjectDeployer;
    get appAddress(): string;
    get app(): App | null;
    private _migrate;
    private migrateManifestVersionIfNeeded;
    publish(): Promise<void>;
    createProxy(packageName: string, contractAlias: string, initMethod: string, initArgs: string[], admin?: string, salt?: string, signature?: string, kind?: ProxyType): Promise<Contract>;
    createInstance(packageName: string, contractAlias: string, initArgs: unknown[]): Promise<Contract>;
    private createProxyInstance;
    getProxyDeploymentAddress(salt: string, sender?: string): Promise<string>;
    getProxySignedDeployment(salt: string, signature: string, packageName: string, contractAlias: string, initMethod?: string, initArgs?: string[], admin?: string): Promise<{
        address: string;
        signer: string;
    }>;
    private _checkDeploymentAddress;
    private _tryRegisterProxyAdmin;
    private _tryRegisterProxyFactory;
    checkInitialization(contract: Contract, calledInitMethod: string): void;
    private _updateTruffleDeployedInformation;
    setProxiesAdmin(packageName: string, contractAlias: string, proxyAddress: string, newAdmin: string): Promise<ProxyInterface[]>;
    setProxyAdminOwner(newAdminOwner: string): Promise<void>;
    private _changeProxiesAdmin;
    upgradeProxies(packageName: string, contractAlias: string, proxyAddress: string, initMethod: string, initArgs: string[]): Promise<ProxyInterface[]>;
    private _upgradeProxy;
    private _fetchOwnedProxies;
    deployDependencies(): Promise<void>;
    deployDependencyIfNeeded(depName: string, depVersion: string): Promise<void | never>;
    handleDependenciesLink(): Promise<void>;
    unlinkDependency(depName: string): Promise<void | never>;
    linkDependency(depName: string, depVersion: string): Promise<boolean | void | never>;
    private _errorForContractDeployed;
    private updateManifestVersionsIfNeeded;
}
export {};
