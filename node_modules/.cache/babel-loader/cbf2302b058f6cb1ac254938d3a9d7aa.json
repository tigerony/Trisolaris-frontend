{"ast":null,"code":"import { PNG } from './../../constants/index';\nimport { CurrencyAmount, CAVAX, JSBI, Token, TokenAmount } from '@pangolindex/sdk';\nimport { useMemo } from 'react';\nimport ERC20_INTERFACE from '../../constants/abis/erc20';\nimport { useAllTokens } from '../../hooks/Tokens';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useMulticallContract } from '../../hooks/useContract';\nimport { isAddress } from '../../utils';\nimport { useSingleContractMultipleData, useMultipleContractSingleData } from '../multicall/hooks';\nimport { useTotalPngEarned } from '../stake/hooks';\n/**\n * Returns a map of the given addresses to their eventually consistent ETH balances.\n */\n\nexport function useETHBalances(uncheckedAddresses) {\n  const multicallContract = useMulticallContract();\n  const addresses = useMemo(() => uncheckedAddresses ? uncheckedAddresses.map(isAddress).filter(a => a !== false).sort() : [], [uncheckedAddresses]);\n  const results = useSingleContractMultipleData(multicallContract, 'getEthBalance', addresses.map(address => [address]));\n  return useMemo(() => addresses.reduce((memo, address, i) => {\n    var _results$i, _results$i$result;\n\n    const value = results === null || results === void 0 ? void 0 : (_results$i = results[i]) === null || _results$i === void 0 ? void 0 : (_results$i$result = _results$i.result) === null || _results$i$result === void 0 ? void 0 : _results$i$result[0];\n    if (value) memo[address] = CurrencyAmount.ether(JSBI.BigInt(value.toString()));\n    return memo;\n  }, {}), [addresses, results]);\n}\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\n\nexport function useTokenBalancesWithLoadingIndicator(address, tokens) {\n  const validatedTokens = useMemo(() => {\n    var _tokens$filter;\n\n    return (_tokens$filter = tokens === null || tokens === void 0 ? void 0 : tokens.filter(t => isAddress(t === null || t === void 0 ? void 0 : t.address) !== false)) !== null && _tokens$filter !== void 0 ? _tokens$filter : [];\n  }, [tokens]);\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map(vt => vt.address), [validatedTokens]);\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address]);\n  const anyLoading = useMemo(() => balances.some(callState => callState.loading), [balances]);\n  return [useMemo(() => address && validatedTokens.length > 0 ? validatedTokens.reduce((memo, token, i) => {\n    var _balances$i, _balances$i$result;\n\n    const value = balances === null || balances === void 0 ? void 0 : (_balances$i = balances[i]) === null || _balances$i === void 0 ? void 0 : (_balances$i$result = _balances$i.result) === null || _balances$i$result === void 0 ? void 0 : _balances$i$result[0];\n    const amount = value ? JSBI.BigInt(value.toString()) : undefined;\n\n    if (amount) {\n      memo[token.address] = new TokenAmount(token, amount);\n    }\n\n    return memo;\n  }, {}) : {}, [address, validatedTokens, balances]), anyLoading];\n}\nexport function useTokenBalances(address, tokens) {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0];\n} // get the balance for a single token/account combo\n\nexport function useTokenBalance(account, token) {\n  const tokenBalances = useTokenBalances(account, [token]);\n  if (!token) return undefined;\n  return tokenBalances[token.address];\n}\nexport function useCurrencyBalances(account, currencies) {\n  const tokens = useMemo(() => {\n    var _currencies$filter;\n\n    return (_currencies$filter = currencies === null || currencies === void 0 ? void 0 : currencies.filter(currency => currency instanceof Token)) !== null && _currencies$filter !== void 0 ? _currencies$filter : [];\n  }, [currencies]);\n  const tokenBalances = useTokenBalances(account, tokens);\n  const containsETH = useMemo(() => {\n    var _currencies$some;\n\n    return (_currencies$some = currencies === null || currencies === void 0 ? void 0 : currencies.some(currency => currency === CAVAX)) !== null && _currencies$some !== void 0 ? _currencies$some : false;\n  }, [currencies]);\n  const ethBalance = useETHBalances(containsETH ? [account] : []);\n  return useMemo(() => {\n    var _currencies$map;\n\n    return (_currencies$map = currencies === null || currencies === void 0 ? void 0 : currencies.map(currency => {\n      if (!account || !currency) return undefined;\n      if (currency instanceof Token) return tokenBalances[currency.address];\n      if (currency === CAVAX) return ethBalance[account];\n      return undefined;\n    })) !== null && _currencies$map !== void 0 ? _currencies$map : [];\n  }, [account, currencies, ethBalance, tokenBalances]);\n}\nexport function useCurrencyBalance(account, currency) {\n  return useCurrencyBalances(account, [currency])[0];\n} // mimics useAllBalances\n\nexport function useAllTokenBalances() {\n  const {\n    account\n  } = useActiveWeb3React();\n  const allTokens = useAllTokens();\n  const allTokensArray = useMemo(() => Object.values(allTokens !== null && allTokens !== void 0 ? allTokens : {}), [allTokens]);\n  const balances = useTokenBalances(account !== null && account !== void 0 ? account : undefined, allTokensArray);\n  return balances !== null && balances !== void 0 ? balances : {};\n} // get the total owned and unharvested PNG for account\n\nexport function useAggregatePngBalance() {\n  var _pngBalance$raw, _pngUnHarvested$raw;\n\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const png = chainId ? PNG[chainId] : undefined;\n  const pngBalance = useTokenBalance(account !== null && account !== void 0 ? account : undefined, png);\n  const pngUnHarvested = useTotalPngEarned();\n  if (!png) return undefined;\n  return new TokenAmount(png, JSBI.add((_pngBalance$raw = pngBalance === null || pngBalance === void 0 ? void 0 : pngBalance.raw) !== null && _pngBalance$raw !== void 0 ? _pngBalance$raw : JSBI.BigInt(0), (_pngUnHarvested$raw = pngUnHarvested === null || pngUnHarvested === void 0 ? void 0 : pngUnHarvested.raw) !== null && _pngUnHarvested$raw !== void 0 ? _pngUnHarvested$raw : JSBI.BigInt(0)));\n}","map":{"version":3,"sources":["/Users/sidshekhar/Documents/interface/src/state/wallet/hooks.ts"],"names":["PNG","CurrencyAmount","CAVAX","JSBI","Token","TokenAmount","useMemo","ERC20_INTERFACE","useAllTokens","useActiveWeb3React","useMulticallContract","isAddress","useSingleContractMultipleData","useMultipleContractSingleData","useTotalPngEarned","useETHBalances","uncheckedAddresses","multicallContract","addresses","map","filter","a","sort","results","address","reduce","memo","i","value","result","ether","BigInt","toString","useTokenBalancesWithLoadingIndicator","tokens","validatedTokens","t","validatedTokenAddresses","vt","balances","anyLoading","some","callState","loading","length","token","amount","undefined","useTokenBalances","useTokenBalance","account","tokenBalances","useCurrencyBalances","currencies","currency","containsETH","ethBalance","useCurrencyBalance","useAllTokenBalances","allTokens","allTokensArray","Object","values","useAggregatePngBalance","chainId","png","pngBalance","pngUnHarvested","add","raw"],"mappings":"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","sourcesContent":["import { PNG } from './../../constants/index'\nimport { Currency, CurrencyAmount, CAVAX, JSBI, Token, TokenAmount } from '@pangolindex/sdk'\nimport { useMemo } from 'react'\nimport ERC20_INTERFACE from '../../constants/abis/erc20'\nimport { useAllTokens } from '../../hooks/Tokens'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useMulticallContract } from '../../hooks/useContract'\nimport { isAddress } from '../../utils'\nimport { useSingleContractMultipleData, useMultipleContractSingleData } from '../multicall/hooks'\nimport { useTotalPngEarned } from '../stake/hooks'\n\n\n/**\n * Returns a map of the given addresses to their eventually consistent ETH balances.\n */\nexport function useETHBalances(\n  uncheckedAddresses?: (string | undefined)[]\n): { [address: string]: CurrencyAmount | undefined } {\n  const multicallContract = useMulticallContract()\n\n  const addresses: string[] = useMemo(\n    () =>\n      uncheckedAddresses\n        ? uncheckedAddresses\n          .map(isAddress)\n          .filter((a): a is string => a !== false)\n          .sort()\n        : [],\n    [uncheckedAddresses]\n  )\n\n  const results = useSingleContractMultipleData(\n    multicallContract,\n    'getEthBalance',\n    addresses.map(address => [address])\n  )\n\n  return useMemo(\n    () =>\n      addresses.reduce<{ [address: string]: CurrencyAmount }>((memo, address, i) => {\n        const value = results?.[i]?.result?.[0]\n        if (value) memo[address] = CurrencyAmount.ether(JSBI.BigInt(value.toString()))\n        return memo\n      }, {}),\n    [addresses, results]\n  )\n}\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): [{ [tokenAddress: string]: TokenAmount | undefined }, boolean] {\n  const validatedTokens: Token[] = useMemo(\n    () => tokens?.filter((t?: Token): t is Token => isAddress(t?.address) !== false) ?? [],\n    [tokens]\n  )\n\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map(vt => vt.address), [validatedTokens])\n\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address])\n\n  const anyLoading: boolean = useMemo(() => balances.some(callState => callState.loading), [balances])\n\n  return [\n    useMemo(\n      () =>\n        address && validatedTokens.length > 0\n          ? validatedTokens.reduce<{ [tokenAddress: string]: TokenAmount | undefined }>((memo, token, i) => {\n            const value = balances?.[i]?.result?.[0]\n            const amount = value ? JSBI.BigInt(value.toString()) : undefined\n            if (amount) {\n              memo[token.address] = new TokenAmount(token, amount)\n            }\n            return memo\n          }, {})\n          : {},\n      [address, validatedTokens, balances]\n    ),\n    anyLoading\n  ]\n}\n\nexport function useTokenBalances(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): { [tokenAddress: string]: TokenAmount | undefined } {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0]\n}\n\n// get the balance for a single token/account combo\nexport function useTokenBalance(account?: string, token?: Token): TokenAmount | undefined {\n  const tokenBalances = useTokenBalances(account, [token])\n  if (!token) return undefined\n  return tokenBalances[token.address]\n}\n\nexport function useCurrencyBalances(\n  account?: string,\n  currencies?: (Currency | undefined)[]\n): (CurrencyAmount | undefined)[] {\n  const tokens = useMemo(() => currencies?.filter((currency): currency is Token => currency instanceof Token) ?? [], [\n    currencies\n  ])\n\n  const tokenBalances = useTokenBalances(account, tokens)\n  const containsETH: boolean = useMemo(() => currencies?.some(currency => currency === CAVAX) ?? false, [currencies])\n  const ethBalance = useETHBalances(containsETH ? [account] : [])\n\n  return useMemo(\n    () =>\n      currencies?.map(currency => {\n        if (!account || !currency) return undefined\n        if (currency instanceof Token) return tokenBalances[currency.address]\n        if (currency === CAVAX) return ethBalance[account]\n        return undefined\n      }) ?? [],\n    [account, currencies, ethBalance, tokenBalances]\n  )\n}\n\nexport function useCurrencyBalance(account?: string, currency?: Currency): CurrencyAmount | undefined {\n  return useCurrencyBalances(account, [currency])[0]\n}\n\n// mimics useAllBalances\nexport function useAllTokenBalances(): { [tokenAddress: string]: TokenAmount | undefined } {\n  const { account } = useActiveWeb3React()\n  const allTokens = useAllTokens()\n  const allTokensArray = useMemo(() => Object.values(allTokens ?? {}), [allTokens])\n  const balances = useTokenBalances(account ?? undefined, allTokensArray)\n  return balances ?? {}\n}\n\n// get the total owned and unharvested PNG for account\nexport function useAggregatePngBalance(): TokenAmount | undefined {\n  const { account, chainId } = useActiveWeb3React()\n\n  const png = chainId ? PNG[chainId] : undefined\n\n  const pngBalance: TokenAmount | undefined = useTokenBalance(account ?? undefined, png)\n  const pngUnHarvested: TokenAmount | undefined = useTotalPngEarned()\n\n  if (!png) return undefined\n\n  return new TokenAmount(\n    png,\n    JSBI.add(\n      pngBalance?.raw ?? JSBI.BigInt(0),\n      pngUnHarvested?.raw ?? JSBI.BigInt(0)\n    )\n  )\n}"]},"metadata":{},"sourceType":"module"}