{"ast":null,"code":"import { useEffect, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useBlockNumber } from '../application/hooks';\nimport { addMulticallListeners, removeMulticallListeners, parseCallKey, toCallKey } from './actions';\n\nfunction isMethodArg(x) {\n  return ['string', 'number'].indexOf(typeof x) !== -1;\n}\n\nfunction isValidMethodArgs(x) {\n  return x === undefined || Array.isArray(x) && x.every(xi => isMethodArg(xi) || Array.isArray(xi) && xi.every(isMethodArg));\n}\n\nconst INVALID_RESULT = {\n  valid: false,\n  blockNumber: undefined,\n  data: undefined\n}; // use this options object\n\nexport const NEVER_RELOAD = {\n  blocksPerFetch: Infinity\n}; // the lowest level call for subscribing to contract data\n\nfunction useCallsData(calls, options) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const callResults = useSelector(state => state.multicall.callResults);\n  const dispatch = useDispatch();\n  const serializedCallKeys = useMemo(() => {\n    var _calls$filter$map$sor, _calls$filter, _calls$filter$map;\n\n    return JSON.stringify((_calls$filter$map$sor = calls === null || calls === void 0 ? void 0 : (_calls$filter = calls.filter(c => Boolean(c))) === null || _calls$filter === void 0 ? void 0 : (_calls$filter$map = _calls$filter.map(toCallKey)) === null || _calls$filter$map === void 0 ? void 0 : _calls$filter$map.sort()) !== null && _calls$filter$map$sor !== void 0 ? _calls$filter$map$sor : []);\n  }, [calls]); // update listeners when there is an actual change that persists for at least 100ms\n\n  useEffect(() => {\n    const callKeys = JSON.parse(serializedCallKeys);\n    if (!chainId || callKeys.length === 0) return undefined;\n    const calls = callKeys.map(key => parseCallKey(key));\n    dispatch(addMulticallListeners({\n      chainId,\n      calls,\n      options\n    }));\n    return () => {\n      dispatch(removeMulticallListeners({\n        chainId,\n        calls,\n        options\n      }));\n    };\n  }, [chainId, dispatch, options, serializedCallKeys]);\n  return useMemo(() => calls.map(call => {\n    var _callResults$chainId;\n\n    if (!chainId || !call) return INVALID_RESULT;\n    const result = (_callResults$chainId = callResults[chainId]) === null || _callResults$chainId === void 0 ? void 0 : _callResults$chainId[toCallKey(call)];\n    let data;\n\n    if ((result === null || result === void 0 ? void 0 : result.data) && (result === null || result === void 0 ? void 0 : result.data) !== '0x') {\n      data = result.data;\n    }\n\n    return {\n      valid: true,\n      data,\n      blockNumber: result === null || result === void 0 ? void 0 : result.blockNumber\n    };\n  }), [callResults, calls, chainId]);\n}\n\nconst INVALID_CALL_STATE = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false\n};\nconst LOADING_CALL_STATE = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false\n};\n\nfunction toCallState(callResult, contractInterface, fragment, latestBlockNumber) {\n  if (!callResult) return INVALID_CALL_STATE;\n  const {\n    valid,\n    data,\n    blockNumber\n  } = callResult;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  const success = data && data.length > 2;\n  const syncing = (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) < latestBlockNumber;\n  let result = undefined;\n\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result\n      };\n    }\n  }\n\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success\n  };\n}\n\nexport function useSingleContractMultipleData(contract, methodName, callInputs, options) {\n  const fragment = useMemo(() => {\n    var _contract$interface;\n\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface = contract.interface) === null || _contract$interface === void 0 ? void 0 : _contract$interface.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => contract && fragment && callInputs && callInputs.length > 0 ? callInputs.map(inputs => {\n    return {\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    };\n  }) : [], [callInputs, contract, fragment]);\n  const results = useCallsData(calls, options);\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber));\n  }, [fragment, contract, results, latestBlockNumber]);\n}\nexport function useMultipleContractSingleData(addresses, contractInterface, methodName, callInputs, options) {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName]);\n  const callData = useMemo(() => fragment && isValidMethodArgs(callInputs) ? contractInterface.encodeFunctionData(fragment, callInputs) : undefined, [callInputs, contractInterface, fragment]);\n  const calls = useMemo(() => fragment && addresses && addresses.length > 0 && callData ? addresses.map(address => {\n    return address && callData ? {\n      address,\n      callData\n    } : undefined;\n  }) : [], [addresses, callData, fragment]);\n  const results = useCallsData(calls, options);\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contractInterface, fragment, latestBlockNumber));\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\nexport function useSingleCallResult(contract, methodName, inputs, options) {\n  const fragment = useMemo(() => {\n    var _contract$interface2;\n\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface2 = contract.interface) === null || _contract$interface2 === void 0 ? void 0 : _contract$interface2.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => {\n    return contract && fragment && isValidMethodArgs(inputs) ? [{\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    }] : [];\n  }, [contract, fragment, inputs]);\n  const result = useCallsData(calls, options)[0];\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);\n  }, [result, contract, fragment, latestBlockNumber]);\n}","map":{"version":3,"sources":["/Users/sidshekhar/Documents/interface/src/state/multicall/hooks.ts"],"names":["useEffect","useMemo","useDispatch","useSelector","useActiveWeb3React","useBlockNumber","addMulticallListeners","removeMulticallListeners","parseCallKey","toCallKey","isMethodArg","x","indexOf","isValidMethodArgs","undefined","Array","isArray","every","xi","INVALID_RESULT","valid","blockNumber","data","NEVER_RELOAD","blocksPerFetch","Infinity","useCallsData","calls","options","chainId","callResults","state","multicall","dispatch","serializedCallKeys","JSON","stringify","filter","c","Boolean","map","sort","callKeys","parse","length","key","call","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","useSingleContractMultipleData","contract","methodName","callInputs","interface","getFunction","inputs","address","callData","encodeFunctionData","results","useMultipleContractSingleData","addresses","useSingleCallResult"],"mappings":"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","sourcesContent":["import { Interface, FunctionFragment } from '@ethersproject/abi'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport { useEffect, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  addMulticallListeners,\n  Call,\n  removeMulticallListeners,\n  parseCallKey,\n  toCallKey,\n  ListenerOptions\n} from './actions'\n\nexport interface Result extends ReadonlyArray<any> {\n  readonly [key: string]: any\n}\n\ntype MethodArg = string | number | BigNumber\ntype MethodArgs = Array<MethodArg | MethodArg[]>\n\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined\n\nfunction isMethodArg(x: unknown): x is MethodArg {\n  return ['string', 'number'].indexOf(typeof x) !== -1\n}\n\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\n  return (\n    x === undefined ||\n    (Array.isArray(x) && x.every(xi => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\n  )\n}\n\ninterface CallResult {\n  readonly valid: boolean\n  readonly data: string | undefined\n  readonly blockNumber: number | undefined\n}\n\nconst INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined }\n\n// use this options object\nexport const NEVER_RELOAD: ListenerOptions = {\n  blocksPerFetch: Infinity\n}\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls: (Call | undefined)[], options?: ListenerOptions): CallResult[] {\n  const { chainId } = useActiveWeb3React()\n  const callResults = useSelector<AppState, AppState['multicall']['callResults']>(state => state.multicall.callResults)\n  const dispatch = useDispatch<AppDispatch>()\n\n  const serializedCallKeys: string = useMemo(\n    () =>\n      JSON.stringify(\n        calls\n          ?.filter((c): c is Call => Boolean(c))\n          ?.map(toCallKey)\n          ?.sort() ?? []\n      ),\n    [calls]\n  )\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys: string[] = JSON.parse(serializedCallKeys)\n    if (!chainId || callKeys.length === 0) return undefined\n    const calls = callKeys.map(key => parseCallKey(key))\n    dispatch(\n      addMulticallListeners({\n        chainId,\n        calls,\n        options\n      })\n    )\n\n    return () => {\n      dispatch(\n        removeMulticallListeners({\n          chainId,\n          calls,\n          options\n        })\n      )\n    }\n  }, [chainId, dispatch, options, serializedCallKeys])\n\n  return useMemo(\n    () =>\n      calls.map<CallResult>(call => {\n        if (!chainId || !call) return INVALID_RESULT\n\n        const result = callResults[chainId]?.[toCallKey(call)]\n        let data\n        if (result?.data && result?.data !== '0x') {\n          data = result.data\n        }\n\n        return { valid: true, data, blockNumber: result?.blockNumber }\n      }),\n    [callResults, calls, chainId]\n  )\n}\n\ninterface CallState {\n  readonly valid: boolean\n  // the result, or undefined if loading or errored/no data\n  readonly result: Result | undefined\n  // true if the result has never been fetched\n  readonly loading: boolean\n  // true if the result is not for the latest block\n  readonly syncing: boolean\n  // true if the call was made and is synced, but the return data is invalid\n  readonly error: boolean\n}\n\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false }\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false }\n\nfunction toCallState(\n  callResult: CallResult | undefined,\n  contractInterface: Interface | undefined,\n  fragment: FunctionFragment | undefined,\n  latestBlockNumber: number | undefined\n): CallState {\n  if (!callResult) return INVALID_CALL_STATE\n  const { valid, data, blockNumber } = callResult\n  if (!valid) return INVALID_CALL_STATE\n  if (valid && !blockNumber) return LOADING_CALL_STATE\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE\n  const success = data && data.length > 2\n  const syncing = (blockNumber ?? 0) < latestBlockNumber\n  let result: Result | undefined = undefined\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data)\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data)\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result\n      }\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success\n  }\n}\n\nexport function useSingleContractMultipleData(\n  contract: Contract | null | undefined,\n  methodName: string,\n  callInputs: OptionalMethodInputs[],\n  options?: ListenerOptions\n): CallState[] {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo(\n    () =>\n      contract && fragment && callInputs && callInputs.length > 0\n        ? callInputs.map<Call>(inputs => {\n            return {\n              address: contract.address,\n              callData: contract.interface.encodeFunctionData(fragment, inputs)\n            }\n          })\n        : [],\n    [callInputs, contract, fragment]\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contract?.interface, fragment, latestBlockNumber))\n  }, [fragment, contract, results, latestBlockNumber])\n}\n\nexport function useMultipleContractSingleData(\n  addresses: (string | undefined)[],\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: ListenerOptions\n): CallState[] {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName])\n  const callData: string | undefined = useMemo(\n    () =>\n      fragment && isValidMethodArgs(callInputs)\n        ? contractInterface.encodeFunctionData(fragment, callInputs)\n        : undefined,\n    [callInputs, contractInterface, fragment]\n  )\n\n  const calls = useMemo(\n    () =>\n      fragment && addresses && addresses.length > 0 && callData\n        ? addresses.map<Call | undefined>(address => {\n            return address && callData\n              ? {\n                  address,\n                  callData\n                }\n              : undefined\n          })\n        : [],\n    [addresses, callData, fragment]\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contractInterface, fragment, latestBlockNumber))\n  }, [fragment, results, contractInterface, latestBlockNumber])\n}\n\nexport function useSingleCallResult(\n  contract: Contract | null | undefined,\n  methodName: string,\n  inputs?: OptionalMethodInputs,\n  options?: ListenerOptions\n): CallState {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo<Call[]>(() => {\n    return contract && fragment && isValidMethodArgs(inputs)\n      ? [\n          {\n            address: contract.address,\n            callData: contract.interface.encodeFunctionData(fragment, inputs)\n          }\n        ]\n      : []\n  }, [contract, fragment, inputs])\n\n  const result = useCallsData(calls, options)[0]\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return toCallState(result, contract?.interface, fragment, latestBlockNumber)\n  }, [result, contract, fragment, latestBlockNumber])\n}\n"]},"metadata":{},"sourceType":"module"}