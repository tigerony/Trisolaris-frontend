{"ast":null,"code":"import { UNI } from './../../constants/index';\nimport { TokenAmount } from '@pangolindex/sdk';\nimport { isAddress } from 'ethers/lib/utils';\nimport { useGovernanceContract, usePngContract } from '../../hooks/useContract';\nimport { useSingleCallResult, useSingleContractMultipleData } from '../multicall/hooks';\nimport { useActiveWeb3React } from '../../hooks';\nimport { ethers, utils } from 'ethers';\nimport { calculateGasMargin } from '../../utils';\nimport { useTransactionAdder } from '../transactions/hooks';\nimport { useState, useEffect, useCallback } from 'react';\nimport { abi as GOV_ABI } from '@pangolindex/governance/artifacts/contracts/GovernorAlpha.sol/GovernorAlpha.json';\nimport { GET_BLOCK } from '../../apollo/queries';\nimport { blockClient } from '../../apollo/client';\n\nconst enumerateProposalState = state => {\n  const proposalStates = ['pending', 'active', 'canceled', 'defeated', 'succeeded', 'queued', 'expired', 'executed'];\n  return proposalStates[state];\n}; // get count of all proposals made\n\n\nexport function useProposalCount() {\n  const gov = useGovernanceContract();\n  const res = useSingleCallResult(gov, 'proposalCount');\n\n  if (res.result && !res.loading) {\n    var _parseInt;\n\n    return (_parseInt = parseInt(res.result[0])) !== null && _parseInt !== void 0 ? _parseInt : 0;\n  }\n\n  return undefined;\n}\n/**\n * @notice Fetches first block after a given timestamp\n * @dev Query speed is optimized by limiting to a 600-second period\n * @param {Number} timestamp in seconds\n */\n\nexport async function getBlockFromTimestamp(timestamp) {\n  var _result$data, _result$data$blocks, _result$data$blocks$;\n\n  const result = await blockClient.query({\n    query: GET_BLOCK,\n    variables: {\n      timestampFrom: timestamp,\n      timestampTo: timestamp + 60 * 60 * 24 * 7\n    },\n    fetchPolicy: 'cache-first'\n  });\n  return result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : (_result$data$blocks = _result$data.blocks) === null || _result$data$blocks === void 0 ? void 0 : (_result$data$blocks$ = _result$data$blocks[0]) === null || _result$data$blocks$ === void 0 ? void 0 : _result$data$blocks$.number;\n}\n/**\n * Need proposal events to get description data emitted from\n * new proposal event.\n */\n\nexport function useDataFromEventLogs() {\n  const {\n    library\n  } = useActiveWeb3React();\n  const [formattedEvents, setFormattedEvents] = useState();\n  const govContract = useGovernanceContract();\n  const proposalCount = useProposalCount();\n  const proposalIndexes = [];\n\n  for (let i = 1; i <= (proposalCount !== null && proposalCount !== void 0 ? proposalCount : 0); i++) {\n    proposalIndexes.push([i]);\n  }\n\n  const allProposals = useSingleContractMultipleData(govContract, 'proposals', proposalIndexes);\n  useEffect(() => {\n    const voteDelay = 60 * 60 * 24;\n    const eventParser = new ethers.utils.Interface(GOV_ABI);\n\n    async function fetchData() {\n      var _pastEvents, _pastEvents$map;\n\n      let pastEvents = [];\n\n      for (const proposal of allProposals) {\n        var _proposal$result, _proposal$result$star;\n\n        const startTime = parseInt(proposal === null || proposal === void 0 ? void 0 : (_proposal$result = proposal.result) === null || _proposal$result === void 0 ? void 0 : (_proposal$result$star = _proposal$result.startTime) === null || _proposal$result$star === void 0 ? void 0 : _proposal$result$star.toString());\n\n        if (startTime) {\n          var _govContract$filters;\n\n          const eventTime = startTime - voteDelay;\n          const block = parseInt(await getBlockFromTimestamp(eventTime)); // Actual returns the \"next\" block\n\n          const filter = { ...(govContract === null || govContract === void 0 ? void 0 : (_govContract$filters = govContract.filters) === null || _govContract$filters === void 0 ? void 0 : _govContract$filters['ProposalCreated']()),\n            fromBlock: block - 10,\n            toBlock: block + 10\n          };\n          pastEvents = pastEvents.concat(await (library === null || library === void 0 ? void 0 : library.getLogs(filter)));\n        }\n      }\n\n      const formattedEventData = (_pastEvents = pastEvents) === null || _pastEvents === void 0 ? void 0 : (_pastEvents$map = _pastEvents.map(event => eventParser.parseLog(event).args)) === null || _pastEvents$map === void 0 ? void 0 : _pastEvents$map.map(eventParsed => ({\n        description: eventParsed.description,\n        details: eventParsed.targets.map((target, i) => {\n          const signature = eventParsed.signatures[i];\n          const [name, types] = signature.substr(0, signature.length - 1).split('(');\n          const calldata = eventParsed.calldatas[i];\n          const decoded = utils.defaultAbiCoder.decode(types.split(','), calldata);\n          return {\n            target,\n            functionSig: name,\n            callData: decoded.join(', ')\n          };\n        })\n      })).reverse(); // reverse events to get them from newest to oldest\n\n      setFormattedEvents(formattedEventData);\n    }\n\n    if (library && govContract && proposalCount !== undefined && allProposals && allProposals.length === proposalCount && allProposals.every(proposal => !proposal.loading) && !formattedEvents) {\n      fetchData();\n    }\n  }, [library, govContract, proposalCount, allProposals, formattedEvents]);\n  return formattedEvents;\n} // get data for all past and active proposals\n\nexport function useAllProposalData() {\n  const proposalCount = useProposalCount();\n  const govContract = useGovernanceContract();\n  const proposalIndexes = [];\n\n  for (let i = 1; i <= (proposalCount !== null && proposalCount !== void 0 ? proposalCount : 0); i++) {\n    proposalIndexes.push([i]);\n  } // get metadata from past events\n\n\n  const formattedEvents = useDataFromEventLogs(); // get all proposal entities\n\n  const allProposals = useSingleContractMultipleData(govContract, 'proposals', proposalIndexes); // get all proposal states\n\n  const allProposalStates = useSingleContractMultipleData(govContract, 'state', proposalIndexes);\n\n  if (formattedEvents && allProposals && allProposalStates) {\n    allProposals.reverse();\n    allProposalStates.reverse();\n    return allProposals.filter((p, i) => {\n      var _allProposalStates$i;\n\n      return Boolean(p.result) && Boolean((_allProposalStates$i = allProposalStates[i]) === null || _allProposalStates$i === void 0 ? void 0 : _allProposalStates$i.result) && Boolean(formattedEvents[i]);\n    }).map((p, i) => {\n      var _allProposals$i, _allProposals$i$resul, _allProposals$i2, _allProposals$i2$resu, _enumerateProposalSta, _allProposalStates$i2, _allProposalStates$i3, _allProposals$i3, _allProposals$i3$resu, _allProposals$i4, _allProposals$i4$resu, _allProposals$i5, _allProposals$i5$resu, _allProposals$i5$resu2, _allProposals$i6, _allProposals$i6$resu, _allProposals$i6$resu2, _allProposals$i7, _allProposals$i7$resu, _allProposals$i7$resu2;\n\n      const description = formattedEvents[i].description;\n      const formattedProposal = {\n        id: (_allProposals$i = allProposals[i]) === null || _allProposals$i === void 0 ? void 0 : (_allProposals$i$resul = _allProposals$i.result) === null || _allProposals$i$resul === void 0 ? void 0 : _allProposals$i$resul.id.toString(),\n        title: (description === null || description === void 0 ? void 0 : description.split(/# |\\n/g)[1]) || 'Untitled',\n        description: description || 'No description.',\n        proposer: (_allProposals$i2 = allProposals[i]) === null || _allProposals$i2 === void 0 ? void 0 : (_allProposals$i2$resu = _allProposals$i2.result) === null || _allProposals$i2$resu === void 0 ? void 0 : _allProposals$i2$resu.proposer,\n        status: (_enumerateProposalSta = enumerateProposalState((_allProposalStates$i2 = allProposalStates[i]) === null || _allProposalStates$i2 === void 0 ? void 0 : (_allProposalStates$i3 = _allProposalStates$i2.result) === null || _allProposalStates$i3 === void 0 ? void 0 : _allProposalStates$i3[0])) !== null && _enumerateProposalSta !== void 0 ? _enumerateProposalSta : 'Undetermined',\n        forCount: parseFloat(ethers.utils.formatUnits((_allProposals$i3 = allProposals[i]) === null || _allProposals$i3 === void 0 ? void 0 : (_allProposals$i3$resu = _allProposals$i3.result) === null || _allProposals$i3$resu === void 0 ? void 0 : _allProposals$i3$resu.forVotes.toString(), 18)),\n        againstCount: parseFloat(ethers.utils.formatUnits((_allProposals$i4 = allProposals[i]) === null || _allProposals$i4 === void 0 ? void 0 : (_allProposals$i4$resu = _allProposals$i4.result) === null || _allProposals$i4$resu === void 0 ? void 0 : _allProposals$i4$resu.againstVotes.toString(), 18)),\n        startTime: parseInt((_allProposals$i5 = allProposals[i]) === null || _allProposals$i5 === void 0 ? void 0 : (_allProposals$i5$resu = _allProposals$i5.result) === null || _allProposals$i5$resu === void 0 ? void 0 : (_allProposals$i5$resu2 = _allProposals$i5$resu.startTime) === null || _allProposals$i5$resu2 === void 0 ? void 0 : _allProposals$i5$resu2.toString()),\n        endTime: parseInt((_allProposals$i6 = allProposals[i]) === null || _allProposals$i6 === void 0 ? void 0 : (_allProposals$i6$resu = _allProposals$i6.result) === null || _allProposals$i6$resu === void 0 ? void 0 : (_allProposals$i6$resu2 = _allProposals$i6$resu.endTime) === null || _allProposals$i6$resu2 === void 0 ? void 0 : _allProposals$i6$resu2.toString()),\n        startBlock: parseInt((_allProposals$i7 = allProposals[i]) === null || _allProposals$i7 === void 0 ? void 0 : (_allProposals$i7$resu = _allProposals$i7.result) === null || _allProposals$i7$resu === void 0 ? void 0 : (_allProposals$i7$resu2 = _allProposals$i7$resu.startBlock) === null || _allProposals$i7$resu2 === void 0 ? void 0 : _allProposals$i7$resu2.toString()),\n        details: formattedEvents[i].details\n      };\n      return formattedProposal;\n    });\n  } else {\n    return [];\n  }\n}\nexport function useProposalData(id) {\n  const allProposalData = useAllProposalData();\n  return allProposalData === null || allProposalData === void 0 ? void 0 : allProposalData.find(p => p.id === id);\n} // get the users delegatee if it exists\n\nexport function useUserDelegatee() {\n  var _result$;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const uniContract = usePngContract();\n  const {\n    result\n  } = useSingleCallResult(uniContract, 'delegates', [account !== null && account !== void 0 ? account : undefined]);\n  return (_result$ = result === null || result === void 0 ? void 0 : result[0]) !== null && _result$ !== void 0 ? _result$ : undefined;\n}\nexport function useUserVotes() {\n  var _useSingleCallResult, _useSingleCallResult$;\n\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const uniContract = usePngContract(); // check for available votes\n\n  const uni = chainId ? UNI[chainId] : undefined;\n  const votes = (_useSingleCallResult = useSingleCallResult(uniContract, 'getCurrentVotes', [account !== null && account !== void 0 ? account : undefined])) === null || _useSingleCallResult === void 0 ? void 0 : (_useSingleCallResult$ = _useSingleCallResult.result) === null || _useSingleCallResult$ === void 0 ? void 0 : _useSingleCallResult$[0];\n  return votes && uni ? new TokenAmount(uni, votes) : undefined;\n}\nexport function useDelegateCallback() {\n  const {\n    account,\n    chainId,\n    library\n  } = useActiveWeb3React();\n  const addTransaction = useTransactionAdder();\n  const uniContract = usePngContract();\n  return useCallback(delegatee => {\n    if (!library || !chainId || !account || !isAddress(delegatee !== null && delegatee !== void 0 ? delegatee : '')) return undefined;\n    const args = [delegatee];\n    if (!uniContract) throw new Error('No UNI Contract!');\n    return uniContract.estimateGas.delegate(...args, {}).then(estimatedGasLimit => {\n      return uniContract.delegate(...args, {\n        value: null,\n        gasLimit: calculateGasMargin(estimatedGasLimit)\n      }).then(response => {\n        addTransaction(response, {\n          summary: `Delegated votes`\n        });\n        return response.hash;\n      });\n    });\n  }, [account, addTransaction, chainId, library, uniContract]);\n}\nexport function useVoteCallback() {\n  const {\n    account\n  } = useActiveWeb3React();\n  const govContract = useGovernanceContract();\n  const addTransaction = useTransactionAdder();\n  const voteCallback = useCallback((proposalId, support) => {\n    if (!account || !govContract || !proposalId) return;\n    const args = [proposalId, support];\n    return govContract.estimateGas.castVote(...args, {}).then(estimatedGasLimit => {\n      return govContract.castVote(...args, {\n        value: null,\n        gasLimit: calculateGasMargin(estimatedGasLimit)\n      }).then(response => {\n        addTransaction(response, {\n          summary: `Voted ${support ? 'for ' : 'against'} proposal ${proposalId}`\n        });\n        return response.hash;\n      });\n    });\n  }, [account, addTransaction, govContract]);\n  return {\n    voteCallback\n  };\n}","map":{"version":3,"sources":["/Users/sidshekhar/Documents/interface/src/state/governance/hooks.ts"],"names":["UNI","TokenAmount","isAddress","useGovernanceContract","usePngContract","useSingleCallResult","useSingleContractMultipleData","useActiveWeb3React","ethers","utils","calculateGasMargin","useTransactionAdder","useState","useEffect","useCallback","abi","GOV_ABI","GET_BLOCK","blockClient","enumerateProposalState","state","proposalStates","useProposalCount","gov","res","result","loading","parseInt","undefined","getBlockFromTimestamp","timestamp","query","variables","timestampFrom","timestampTo","fetchPolicy","data","blocks","number","useDataFromEventLogs","library","formattedEvents","setFormattedEvents","govContract","proposalCount","proposalIndexes","i","push","allProposals","voteDelay","eventParser","Interface","fetchData","pastEvents","proposal","startTime","toString","eventTime","block","filter","filters","fromBlock","toBlock","concat","getLogs","formattedEventData","map","event","parseLog","args","eventParsed","description","details","targets","target","signature","signatures","name","types","substr","length","split","calldata","calldatas","decoded","defaultAbiCoder","decode","functionSig","callData","join","reverse","every","useAllProposalData","allProposalStates","p","Boolean","formattedProposal","id","title","proposer","status","forCount","parseFloat","formatUnits","forVotes","againstCount","againstVotes","endTime","startBlock","useProposalData","allProposalData","find","useUserDelegatee","account","uniContract","useUserVotes","chainId","uni","votes","useDelegateCallback","addTransaction","delegatee","Error","estimateGas","delegate","then","estimatedGasLimit","value","gasLimit","response","summary","hash","useVoteCallback","voteCallback","proposalId","support","castVote"],"mappings":"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","sourcesContent":["import { UNI } from './../../constants/index'\nimport { TokenAmount } from '@pangolindex/sdk'\nimport { isAddress } from 'ethers/lib/utils'\nimport { useGovernanceContract, usePngContract } from '../../hooks/useContract'\nimport { useSingleCallResult, useSingleContractMultipleData } from '../multicall/hooks'\nimport { useActiveWeb3React } from '../../hooks'\nimport { ethers, utils } from 'ethers'\nimport { calculateGasMargin } from '../../utils'\nimport { TransactionResponse } from '@ethersproject/providers'\nimport { useTransactionAdder } from '../transactions/hooks'\nimport { useState, useEffect, useCallback } from 'react'\nimport { abi as GOV_ABI } from '@pangolindex/governance/artifacts/contracts/GovernorAlpha.sol/GovernorAlpha.json'\nimport { GET_BLOCK } from '../../apollo/queries'\nimport { blockClient } from '../../apollo/client'\n\ninterface ProposalDetail {\n  target: string\n  functionSig: string\n  callData: string\n}\n\nexport interface ProposalData {\n  id: string\n  title: string\n  description: string\n  proposer: string\n  status: string\n  forCount: number\n  againstCount: number\n  startTime: number\n  endTime: number\n  startBlock: number\n  details: ProposalDetail[]\n}\n\nconst enumerateProposalState = (state: number) => {\n  const proposalStates = ['pending', 'active', 'canceled', 'defeated', 'succeeded', 'queued', 'expired', 'executed']\n  return proposalStates[state]\n}\n\n// get count of all proposals made\nexport function useProposalCount(): number | undefined {\n  const gov = useGovernanceContract()\n  const res = useSingleCallResult(gov, 'proposalCount')\n  if (res.result && !res.loading) {\n    return parseInt(res.result[0]) ?? 0\n  }\n  return undefined\n}\n\n/**\n * @notice Fetches first block after a given timestamp\n * @dev Query speed is optimized by limiting to a 600-second period\n * @param {Number} timestamp in seconds\n */\nexport async function getBlockFromTimestamp(timestamp: number) {\n  const result = await blockClient.query({\n    query: GET_BLOCK,\n    variables: {\n      timestampFrom: timestamp,\n      timestampTo: timestamp + 60 * 60 * 24 * 7,\n    },\n    fetchPolicy: 'cache-first',\n  })\n  return result?.data?.blocks?.[0]?.number\n}\n\n/**\n * Need proposal events to get description data emitted from\n * new proposal event.\n */\nexport function useDataFromEventLogs() {\n  const { library } = useActiveWeb3React()\n  const [formattedEvents, setFormattedEvents] = useState<any>()\n  const govContract = useGovernanceContract()\n\n  const proposalCount = useProposalCount()\n\n  const proposalIndexes = []\n  for (let i = 1; i <= (proposalCount ?? 0); i++) {\n    proposalIndexes.push([i])\n  }\n\n  const allProposals = useSingleContractMultipleData(govContract, 'proposals', proposalIndexes)\n\n  useEffect(() => {\n    const voteDelay: number = 60 * 60 * 24\n    const eventParser = new ethers.utils.Interface(GOV_ABI)\n\n    async function fetchData() {\n      let pastEvents = [] as any[]\n\n      for (const proposal of allProposals) {\n        const startTime: number = parseInt(proposal?.result?.startTime?.toString())\n        if (startTime) {\n          const eventTime: number = startTime - voteDelay\n          const block: number = parseInt(await getBlockFromTimestamp(eventTime)) // Actual returns the \"next\" block\n          const filter = {\n            ...govContract?.filters?.['ProposalCreated'](),\n            fromBlock: block - 10,\n            toBlock: block + 10\n          }\n          pastEvents = pastEvents.concat(await library?.getLogs(filter))\n        }\n      }\n\n      const formattedEventData = pastEvents\n        ?.map(event => eventParser.parseLog(event).args)\n        ?.map(eventParsed => ({\n          description: eventParsed.description,\n          details: eventParsed.targets.map((target: string, i: number) => {\n            const signature = eventParsed.signatures[i]\n            const [name, types] = signature.substr(0, signature.length - 1).split('(')\n\n            const calldata = eventParsed.calldatas[i]\n            const decoded = utils.defaultAbiCoder.decode(types.split(','), calldata)\n\n            return {\n              target,\n              functionSig: name,\n              callData: decoded.join(', ')\n            }\n          })\n        }))\n        .reverse() // reverse events to get them from newest to oldest\n\n      setFormattedEvents(formattedEventData)\n    }\n\n    if (\n      library &&\n      govContract &&\n      proposalCount !== undefined &&\n      allProposals &&\n      allProposals.length === proposalCount &&\n      allProposals.every(proposal => !proposal.loading) &&\n      !formattedEvents\n    ) {\n      fetchData()\n    }\n  }, [library, govContract, proposalCount, allProposals, formattedEvents])\n\n  return formattedEvents\n}\n\n// get data for all past and active proposals\nexport function useAllProposalData() {\n  const proposalCount = useProposalCount()\n  const govContract = useGovernanceContract()\n\n  const proposalIndexes = []\n  for (let i = 1; i <= (proposalCount ?? 0); i++) {\n    proposalIndexes.push([i])\n  }\n\n  // get metadata from past events\n  const formattedEvents = useDataFromEventLogs()\n\n  // get all proposal entities\n  const allProposals = useSingleContractMultipleData(govContract, 'proposals', proposalIndexes)\n\n  // get all proposal states\n  const allProposalStates = useSingleContractMultipleData(govContract, 'state', proposalIndexes)\n\n  if (formattedEvents && allProposals && allProposalStates) {\n    allProposals.reverse()\n    allProposalStates.reverse()\n\n\n    return allProposals\n      .filter((p, i) => {\n        return Boolean(p.result) && Boolean(allProposalStates[i]?.result) && Boolean(formattedEvents[i])\n      })\n      .map((p, i) => {\n        const description = formattedEvents[i].description\n        const formattedProposal: ProposalData = {\n          id: allProposals[i]?.result?.id.toString(),\n          title: description?.split(/# |\\n/g)[1] || 'Untitled',\n          description: description || 'No description.',\n          proposer: allProposals[i]?.result?.proposer,\n          status: enumerateProposalState(allProposalStates[i]?.result?.[0]) ?? 'Undetermined',\n          forCount: parseFloat(ethers.utils.formatUnits(allProposals[i]?.result?.forVotes.toString(), 18)),\n          againstCount: parseFloat(ethers.utils.formatUnits(allProposals[i]?.result?.againstVotes.toString(), 18)),\n          startTime: parseInt(allProposals[i]?.result?.startTime?.toString()),\n          endTime: parseInt(allProposals[i]?.result?.endTime?.toString()),\n          startBlock: parseInt(allProposals[i]?.result?.startBlock?.toString()),\n          details: formattedEvents[i].details\n        }\n        return formattedProposal\n      })\n  } else {\n    return []\n  }\n}\n\nexport function useProposalData(id: string): ProposalData | undefined {\n  const allProposalData = useAllProposalData()\n  return allProposalData?.find(p => p.id === id)\n}\n\n// get the users delegatee if it exists\nexport function useUserDelegatee(): string {\n  const { account } = useActiveWeb3React()\n  const uniContract = usePngContract()\n  const { result } = useSingleCallResult(uniContract, 'delegates', [account ?? undefined])\n  return result?.[0] ?? undefined\n}\n\nexport function useUserVotes(): TokenAmount | undefined {\n  const { account, chainId } = useActiveWeb3React()\n  const uniContract = usePngContract()\n\n  // check for available votes\n  const uni = chainId ? UNI[chainId] : undefined\n  const votes = useSingleCallResult(uniContract, 'getCurrentVotes', [account ?? undefined])?.result?.[0]\n  return votes && uni ? new TokenAmount(uni, votes) : undefined\n}\n\nexport function useDelegateCallback(): (delegatee: string | undefined) => undefined | Promise<string> {\n  const { account, chainId, library } = useActiveWeb3React()\n  const addTransaction = useTransactionAdder()\n\n  const uniContract = usePngContract()\n\n  return useCallback(\n    (delegatee: string | undefined) => {\n      if (!library || !chainId || !account || !isAddress(delegatee ?? '')) return undefined\n      const args = [delegatee]\n      if (!uniContract) throw new Error('No UNI Contract!')\n      return uniContract.estimateGas.delegate(...args, {}).then(estimatedGasLimit => {\n        return uniContract\n          .delegate(...args, { value: null, gasLimit: calculateGasMargin(estimatedGasLimit) })\n          .then((response: TransactionResponse) => {\n            addTransaction(response, {\n              summary: `Delegated votes`\n            })\n            return response.hash\n          })\n      })\n    },\n    [account, addTransaction, chainId, library, uniContract]\n  )\n}\n\nexport function useVoteCallback(): {\n  voteCallback: (proposalId: string | undefined, support: boolean) => undefined | Promise<string>\n} {\n  const { account } = useActiveWeb3React()\n\n  const govContract = useGovernanceContract()\n  const addTransaction = useTransactionAdder()\n\n  const voteCallback = useCallback(\n    (proposalId: string | undefined, support: boolean) => {\n      if (!account || !govContract || !proposalId) return\n      const args = [proposalId, support]\n      return govContract.estimateGas.castVote(...args, {}).then(estimatedGasLimit => {\n        return govContract\n          .castVote(...args, { value: null, gasLimit: calculateGasMargin(estimatedGasLimit) })\n          .then((response: TransactionResponse) => {\n            addTransaction(response, {\n              summary: `Voted ${support ? 'for ' : 'against'} proposal ${proposalId}`\n            })\n            return response.hash\n          })\n      })\n    },\n    [account, addTransaction, govContract]\n  )\n  return { voteCallback }\n}\n"]},"metadata":{},"sourceType":"module"}