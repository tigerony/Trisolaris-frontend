{"ast":null,"code":"import { ChainId, Token } from '@pangolindex/sdk';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { AEB_TOKENLIST } from '../../constants/lists';\nimport { WAVAX } from '@pangolindex/sdk';\nimport { PNG } from '../../constants';\n\n/**\n * Token instances created from token info.\n */\nexport class WrappedTokenInfo extends Token {\n  constructor(tokenInfo, tags) {\n    super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name);\n    this.tokenInfo = void 0;\n    this.tags = void 0;\n    this.tokenInfo = tokenInfo;\n    this.tags = tags;\n  }\n\n  get logoURI() {\n    return this.tokenInfo.logoURI;\n  }\n\n}\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST = {\n  [ChainId.FUJI]: {},\n  [ChainId.AVALANCHE]: {}\n};\nconst listCache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;\nexport function listToTokenMap(list) {\n  const result = listCache === null || listCache === void 0 ? void 0 : listCache.get(list);\n  if (result) return result;\n  const map = list.tokens.reduce((tokenMap, tokenInfo) => {\n    var _tokenInfo$tags$map$f, _tokenInfo$tags, _tokenInfo$tags$map;\n\n    const tags = (_tokenInfo$tags$map$f = (_tokenInfo$tags = tokenInfo.tags) === null || _tokenInfo$tags === void 0 ? void 0 : (_tokenInfo$tags$map = _tokenInfo$tags.map(tagId => {\n      var _list$tags;\n\n      if (!((_list$tags = list.tags) === null || _list$tags === void 0 ? void 0 : _list$tags[tagId])) return undefined;\n      return { ...list.tags[tagId],\n        id: tagId\n      };\n    })) === null || _tokenInfo$tags$map === void 0 ? void 0 : _tokenInfo$tags$map.filter(x => Boolean(x))) !== null && _tokenInfo$tags$map$f !== void 0 ? _tokenInfo$tags$map$f : [];\n    const token = new WrappedTokenInfo(tokenInfo, tags);\n    if (tokenMap[token.chainId][token.address] !== undefined) throw Error('Duplicate tokens.');\n    return { ...tokenMap,\n      [token.chainId]: { ...tokenMap[token.chainId],\n        [token.address]: token\n      }\n    };\n  }, { ...EMPTY_LIST\n  });\n  listCache === null || listCache === void 0 ? void 0 : listCache.set(list, map);\n  return map;\n}\nexport function useTokenList(urls) {\n  const lists = useSelector(state => state.lists.byUrl);\n  let tokenList = {};\n  return useMemo(() => {\n    ;\n    [].concat(urls || []).forEach(url => {\n      var _lists$url;\n\n      const current = (_lists$url = lists[url]) === null || _lists$url === void 0 ? void 0 : _lists$url.current;\n\n      if (url && current) {\n        try {\n          const data = listToTokenMap(current);\n\n          for (const [chainId, tokens] of Object.entries(data)) {\n            tokenList[chainId] = tokenList[chainId] || {};\n            tokenList[chainId] = { ...tokenList[chainId],\n              ...tokens\n            };\n          }\n        } catch (error) {\n          console.error('Could not show token list due to error', error);\n        }\n      }\n    });\n    return tokenList;\n  }, [lists, urls]);\n}\nexport function useSelectedListUrl() {\n  return useSelector(state => {\n    var _state$lists;\n\n    return [].concat((state === null || state === void 0 ? void 0 : (_state$lists = state.lists) === null || _state$lists === void 0 ? void 0 : _state$lists.selectedListUrl) || []);\n  });\n}\nexport function useSelectedTokenList() {\n  return useTokenList(useSelectedListUrl());\n}\nexport function useSelectedListInfo() {\n  var _ref, _list$current, _list$pendingUpdate, _ref2;\n\n  const selectedListUrl = useSelectedListUrl();\n  const firstSelectedUrl = (_ref = selectedListUrl || []) === null || _ref === void 0 ? void 0 : _ref[0];\n  const listsByUrl = useSelector(state => state.lists.byUrl);\n  const list = firstSelectedUrl ? listsByUrl[firstSelectedUrl] : undefined;\n  return {\n    current: (_list$current = list === null || list === void 0 ? void 0 : list.current) !== null && _list$current !== void 0 ? _list$current : null,\n    pending: (_list$pendingUpdate = list === null || list === void 0 ? void 0 : list.pendingUpdate) !== null && _list$pendingUpdate !== void 0 ? _list$pendingUpdate : null,\n    loading: (list === null || list === void 0 ? void 0 : list.loadingRequestId) !== null,\n    multipleSelected: ((_ref2 = selectedListUrl || []) === null || _ref2 === void 0 ? void 0 : _ref2.length) > 1\n  };\n} // returns all downloaded current lists\n\nexport function useAllLists() {\n  const lists = useSelector(state => state.lists.byUrl);\n  return useMemo(() => Object.keys(lists).map(url => lists[url].current).filter(l => Boolean(l)), [lists]);\n}\nexport function useIsSelectedAEBTokenList() {\n  const selectedListUrl = useSelectedListUrl();\n  const isSelected = (selectedListUrl || []).includes(AEB_TOKENLIST);\n  return isSelected;\n}\nexport function useIsSelectedAEBToken() {\n  var _listsByUrl$AEB_TOKEN, _listsByUrl$AEB_TOKEN2;\n\n  const listsByUrl = useSelector(state => state.lists.byUrl);\n  const allAEBTokens = ((_listsByUrl$AEB_TOKEN = listsByUrl[AEB_TOKENLIST]) === null || _listsByUrl$AEB_TOKEN === void 0 ? void 0 : (_listsByUrl$AEB_TOKEN2 = _listsByUrl$AEB_TOKEN.current) === null || _listsByUrl$AEB_TOKEN2 === void 0 ? void 0 : _listsByUrl$AEB_TOKEN2.tokens) || [];\n  const selectedOutputToken = useSelector(state => state.swap.OUTPUT);\n  const aebToken = allAEBTokens.find(token => (token === null || token === void 0 ? void 0 : token.address) === (selectedOutputToken === null || selectedOutputToken === void 0 ? void 0 : selectedOutputToken.currencyId)); // ignore PNG and WAVAX token\n\n  if ((aebToken === null || aebToken === void 0 ? void 0 : aebToken.address) === PNG[ChainId.AVALANCHE].address || (aebToken === null || aebToken === void 0 ? void 0 : aebToken.address) === WAVAX[ChainId.AVALANCHE].address) {\n    return false;\n  }\n\n  return !!aebToken;\n}","map":{"version":3,"sources":["/Users/sidshekhar/Documents/interface/src/state/lists/hooks.ts"],"names":["ChainId","Token","useMemo","useSelector","AEB_TOKENLIST","WAVAX","PNG","WrappedTokenInfo","constructor","tokenInfo","tags","chainId","address","decimals","symbol","name","logoURI","EMPTY_LIST","FUJI","AVALANCHE","listCache","WeakMap","listToTokenMap","list","result","get","map","tokens","reduce","tokenMap","tagId","undefined","id","filter","x","Boolean","token","Error","set","useTokenList","urls","lists","state","byUrl","tokenList","concat","forEach","url","current","data","Object","entries","error","console","useSelectedListUrl","selectedListUrl","useSelectedTokenList","useSelectedListInfo","firstSelectedUrl","listsByUrl","pending","pendingUpdate","loading","loadingRequestId","multipleSelected","length","useAllLists","keys","l","useIsSelectedAEBTokenList","isSelected","includes","useIsSelectedAEBToken","allAEBTokens","selectedOutputToken","swap","OUTPUT","aebToken","find","currencyId"],"mappings":"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","sourcesContent":["import { ChainId, Token } from '@pangolindex/sdk'\nimport { Tags, TokenInfo, TokenList } from '@pangolindex/token-lists'\nimport { useMemo } from 'react'\nimport { useSelector } from 'react-redux'\nimport { AppState } from '../index'\nimport { AEB_TOKENLIST } from '../../constants/lists'\nimport { WAVAX } from '@pangolindex/sdk'\nimport { PNG } from '../../constants'\n\ntype TagDetails = Tags[keyof Tags]\nexport interface TagInfo extends TagDetails {\n  id: string\n}\n\n/**\n * Token instances created from token info.\n */\nexport class WrappedTokenInfo extends Token {\n  public readonly tokenInfo: TokenInfo\n  public readonly tags: TagInfo[]\n  constructor(tokenInfo: TokenInfo, tags: TagInfo[]) {\n    super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name)\n    this.tokenInfo = tokenInfo\n    this.tags = tags\n  }\n  public get logoURI(): string | undefined {\n    return this.tokenInfo.logoURI\n  }\n}\n\nexport type TokenAddressMap = Readonly<{ [chainId in ChainId]: Readonly<{ [tokenAddress: string]: WrappedTokenInfo }> }>\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST: TokenAddressMap = {\n  [ChainId.FUJI]: {},\n  [ChainId.AVALANCHE]: {}\n}\n\nconst listCache: WeakMap<TokenList, TokenAddressMap> | null =\n  typeof WeakMap !== 'undefined' ? new WeakMap<TokenList, TokenAddressMap>() : null\n\nexport function listToTokenMap(list: TokenList): TokenAddressMap {\n  const result = listCache?.get(list)\n\n  if (result) return result\n\n  const map = list.tokens.reduce<TokenAddressMap>(\n    (tokenMap, tokenInfo) => {\n      const tags: TagInfo[] =\n        tokenInfo.tags\n          ?.map(tagId => {\n            if (!list.tags?.[tagId]) return undefined\n            return { ...list.tags[tagId], id: tagId }\n          })\n          ?.filter((x): x is TagInfo => Boolean(x)) ?? []\n      const token = new WrappedTokenInfo(tokenInfo, tags)\n      if (tokenMap[token.chainId][token.address] !== undefined) throw Error('Duplicate tokens.')\n      return {\n        ...tokenMap,\n        [token.chainId]: {\n          ...tokenMap[token.chainId],\n          [token.address]: token\n        }\n      }\n    },\n    { ...EMPTY_LIST }\n  )\n  listCache?.set(list, map)\n  return map\n}\n\nexport function useTokenList(urls: string[] | undefined): TokenAddressMap {\n  const lists = useSelector<AppState, AppState['lists']['byUrl']>(state => state.lists.byUrl)\n\n  let tokenList = {} as { [chainId: string]: { [tokenAddress: string]: WrappedTokenInfo } }\n  return useMemo(() => {\n    ;([] as string[]).concat(urls || []).forEach(url => {\n      const current = lists[url]?.current\n      if (url && current) {\n        try {\n          const data = listToTokenMap(current)\n          for (const [chainId, tokens] of Object.entries(data)) {\n            tokenList[chainId] = tokenList[chainId] || {}\n            tokenList[chainId] = {\n              ...tokenList[chainId],\n              ...tokens\n            }\n          }\n        } catch (error) {\n          console.error('Could not show token list due to error', error)\n        }\n      }\n    })\n    return tokenList as TokenAddressMap\n  }, [lists, urls])\n}\n\nexport function useSelectedListUrl(): string[] | undefined {\n  return useSelector<AppState, AppState['lists']['selectedListUrl']>(state =>\n    ([] as string[]).concat(state?.lists?.selectedListUrl || [])\n  )\n}\n\nexport function useSelectedTokenList(): TokenAddressMap {\n  return useTokenList(useSelectedListUrl())\n}\n\nexport function useSelectedListInfo(): {\n  current: TokenList | null\n  pending: TokenList | null\n  loading: boolean\n  multipleSelected: boolean\n} {\n  const selectedListUrl = useSelectedListUrl()\n  const firstSelectedUrl = (selectedListUrl || [])?.[0]\n  const listsByUrl = useSelector<AppState, AppState['lists']['byUrl']>(state => state.lists.byUrl)\n  const list = firstSelectedUrl ? listsByUrl[firstSelectedUrl] : undefined\n  return {\n    current: list?.current ?? null,\n    pending: list?.pendingUpdate ?? null,\n    loading: list?.loadingRequestId !== null,\n    multipleSelected: (selectedListUrl || [])?.length > 1\n  }\n}\n\n// returns all downloaded current lists\nexport function useAllLists(): TokenList[] {\n  const lists = useSelector<AppState, AppState['lists']['byUrl']>(state => state.lists.byUrl)\n\n  return useMemo(\n    () =>\n      Object.keys(lists)\n        .map(url => lists[url].current)\n        .filter((l): l is TokenList => Boolean(l)),\n    [lists]\n  )\n}\n\nexport function useIsSelectedAEBTokenList(): Boolean {\n  const selectedListUrl = useSelectedListUrl()\n  const isSelected = (selectedListUrl || []).includes(AEB_TOKENLIST)\n  return isSelected\n}\n\nexport function useIsSelectedAEBToken(): Boolean {\n  const listsByUrl = useSelector<AppState, AppState['lists']['byUrl']>(state => state.lists.byUrl)\n\n  const allAEBTokens = listsByUrl[AEB_TOKENLIST]?.current?.tokens || []\n\n  const selectedOutputToken = useSelector<AppState, AppState['swap']['OUTPUT']>(state => state.swap.OUTPUT)\n\n  const aebToken = allAEBTokens.find(token => token?.address === selectedOutputToken?.currencyId)\n\n  // ignore PNG and WAVAX token\n  if (aebToken?.address === PNG[ChainId.AVALANCHE].address || aebToken?.address === WAVAX[ChainId.AVALANCHE].address) {\n    return false\n  }\n\n  return !!aebToken\n}\n"]},"metadata":{},"sourceType":"module"}